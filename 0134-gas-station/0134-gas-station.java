class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        // 하나의 순환경로 사이에 n개의 가스스테이션이 있다.

        // i번째 스테이션에서 얻을수 있는 가스의 양은 gas[i]이다.
        // 제한없는 가스탱크를 갖고있는 차를 가지고서 i번째 스테이션에서 i + 1번째 스테이션까지의 여행에 필요한 비용은 cost[i] 이다.
        // 너는 빈 가스탱크를 가지고 가스 스테이션들 중 하나에서 여행을 시작한다.

        // 시작 주유소의 인덱스를 반환하라, 시계방향으로 한바퀴 돌 수 있는
        // 그러한 답이 없다면 -1을 반환하라.

        // 총 가스스테이션에 길이는 n이며 10만까지 올 수 있다.
        // 정답은 유일함이 보장된다.

        // 어떠한 구간에서도 0이하로 떨어지면 안된다.
        // 그리고 어디에서나 결국 총 비용은 똑같다. 다만, 중간에 누적에 있어서 음수가 발생하면 순환이 불가능하다는 것이다.
        // 중요한것은, 결국 총 비용보다 총 얻을 수 있는 가스양이 크다면 어디에서 출발하느냐에 따라 문제조건을 만족하는것이 달라진단 것이다.

        // 그러면, 출발점을 옮겨야하는 순간은 언제일까?
        // 바로 음수로 더이상 이동이 불가한 상태일 때, 해당 가스스테이션 i + 1 부터로 시작점을 조정한다.
        // 왜 i + 1인가? : i 라고 가정해보자. i - 1 까지 양수였다가 음수로 떨어졌단건, 어쨋든 gas[i], cost[i]번째에서도 손해를 봤다는것이다.
        // 그러면 i ~ i + 1 구간에서 문제가 발생한것이니까 i + 1로 출발점을 잡는것이다.
        // 만약 ~ i 번째중에 정답이 있을 수 있지않냐? 라는 반박은 그전 값들은 더더욱 지난 누적보다 작아지기 때문에 무조건 i ~ i + 1의 음수구간에서 이동못해버릴게 뻔하다.

        int total = 0;
        int sum = 0;
        int start = 0;
        for(int i = 0; i < gas.length; i++) {
            sum += (gas[i] - cost[i]);
            total += (gas[i] - cost[i]);
            if (sum < 0) {
                sum = 0;
                start = i + 1;
            }
        }

        return total < 0 ? -1 : start;
    }
}